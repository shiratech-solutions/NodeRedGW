[{"id":"9098fbe5.d1cd48","type":"function","z":"91830877.d26b18","name":"iCoMox Parser def","func":"","outputs":1,"noerr":0,"initialize":"/*\nThe iCOMOX parser object.\nThis parser can be used to parse binary messages received from the iCOMOX and to build binary messages which can be sent to the iCOMOX.\nIt does not store any information and can be instantiated once and reused\n\nTo create an instance of the class:\nNodeJS:\nvar iCOMOXParser = require('./iCOMOXParser.js');  //Require file in project\nvar parser = new iCOMOXParser();\t\t\t\t//Instantiate the class\n\n\nNodeRed:\nImport the iCOMOXParser.json flow, the node creates an instance of the parser as the global variable \"iCOMOX\" and can be accessed using:\nvar iCOMOXParser = global.get('iCOMOX');\n\nTo create manually, copy the code and set as a global variable:\nglobal.set('iCOMOX', new parser());\n\nTo parse an incoming binary message from the iCOMOX to a JSON object:\nvar obj = parser.objectGet(bin);  //Conversion of binary to object  Example - bin is a buffer\n\n\nTo build a binary message from a JSON use:\nvar bin = parser.binaryMsgGet(obj);  //Conversion of a json object to binary buffer\n\nobj structure:\n{\n\t\"Type\": text, can be  \"Hello\"/\"Reset\"/\"GetConfig\"/\"SetConfig\"/\"Report\"\n\t\"Data\": Message data, according to message type, information in examples\n}\t\n\n*/\n\nvar parser = function iCOMOXParser(binaryData) {\n\tthis.VERSION = \"0.0.3\";\n\t\n\tconst BOARD_TYPE = [\"SMIP\",\"NB_IOT\",\"POE\"];\n\tconst FW_BRANCH = [\"Kit\",\"Suitcase\"];\n\tconst COMM_CHANNEL = [\"USB\",\"Aux\"];\n\tconst MODULE = [\"RawData\",\"Anomaly\"];\n\tconst RESET_TYPE = [\"SW\",\"HW\", \"FWUpdate\"];\n\n\t//Utility functions\n\tvar twoDigStr =  function(num){\n\t\treturn ('0' + (num).toString(10)).slice(-2);\n\t}\n\tvar toHexStr =  function(num){\n\t\treturn ('0' + (num).toString(16)).slice(-2);\n\t}\n\t\n\t//Message parsers - Hello\n\t// Hello request\n\tvar helloMessageBinGet = function() {\n\t\treturn new Buffer.alloc(1);\n\t}\n\t\n\t//Hello response\n\tvar helloMessageObjGet = function(binaryData) {\n\t\tvar res = {};\n\t\tif ((binaryData[1] >= BOARD_TYPE.length) || (binaryData[23] >= FW_BRANCH.length))\n\t\t\treturn null;\n\t\t\n\t\tif (binaryData.length < 128)\n\t\t\treturn null;\n\t\t\n\t\tres[\"BoardType\"] = BOARD_TYPE[binaryData[1]];\n\t\tres[\"BoardVer\"] = binaryData[2] + \".\" + binaryData[3];\n\t\tres[\"MCUSerial\"]=\"\";\n\t\tfor (var i=0; i< 16; i++)\n\t\t\tres[\"MCUSerial\"]+= toHexStr(binaryData[4+i]);   \n\t\tres[\"FwVer\"] = binaryData[20] + \".\" + binaryData[21] + \".\" + binaryData[22] + FW_BRANCH[binaryData[23]];\n\t\tres[\"FwBuild\"] = \tbinaryData[27] + \".\"  + binaryData[26] + \".\" + binaryData.readInt16LE(24)  +   \" \" + binaryData[28] + \":\" + twoDigStr(binaryData[29]) + \":\" + twoDigStr(binaryData[30]);\n\t\tres[\"BitStatus\"] = \"0x\" + toHexStr(binaryData[31]);\n\t\tres[\"PartNum\"] = binaryData.slice(32,32+32).toString().replace(/\\0[\\s\\S]*$/g,'');\n\t\tres[\"Serial\"] = binaryData.slice(64,64+32).toString().replace(/\\0[\\s\\S]*$/g,'');\n\t\tres[\"Name\"] = binaryData.slice(96,96+32).toString().replace(/\\0[\\s\\S]*$/g,'');\n\t\t\n\t\treturn res;\n\t}\n\t\n\t\n\t//Message parsers - Reset\n\t//Reset request\n\tvar resetMessageBinGet = function(obj) {\n\t\tif (!obj)\n\t\t\treturn null;\n\t\tres = new Buffer.alloc(2);\n\t\t\n\t\tfor (var i=0; i < RESET_TYPE.length;  i++){\n\t\t\tif (obj[\"ResetType\"] == RESET_TYPE[i])\n\t\t\t\tres[1]=i;\n\t\t}\n\t\treturn res;\n\t}\n\t//Reset response\n\tvar resetMessageObjGet = function(binaryData) {\n\t\tif (binaryData.length != 1)\n\t\t\treturn null;\n\t\treturn {\"Ack\":true};\n\t}\n\t\n\t//Message parsers - Reports\n\tvar timestampGet = function(binaryData) {\n\t\tif (binaryData.length < 10)\n\t\t\treturn null;\t\t\n\t\t\n\t\treturn new Date((Number(binaryData.readBigInt64LE(2) ) /32768) * 1000);\n\t\t\n\t}\n\tvar reportMessageObjGet = function(binaryData) {\n\t\tvar res = {};\n\t\t\n\t\tif (binaryData[1] >= REPORT_TYPE.length)\n\t\t\treturn null;\n\t\tres.ReportType = REPORT_TYPE[binaryData[1]].name;\n\t\tres[res.ReportType] = REPORT_TYPE[binaryData[1]].func(binaryData);\n\t\tif (res[res.ReportType] == null)\n\t\t\treturn null;\n\t\tres[\"Timestamp\"] = timestampGet(binaryData);\n\t\t\n\t\treturn res;\n\t}\n\t\n\t\n\t\n\t\n\t\n\t//Reports - Accelerometer 1\t\n\tvar accelerometer1ObjGet = function(binaryData) {\n\t\t//Number of samples per axis\n\t\tvar len = \t(binaryData.length - 10) / (3*2);\t\n\t\tvar res = {X:new Float32Array(len),Y:new Float32Array(len),Z:new Float32Array(len)};\n\t\t\n\t\t \n\t\tfor (var i=0; i < len; i++){\n\t\t\tres.X[i] = binaryData.readInt16LE(10 + i*6) / 1024;\n\t\t\tres.Y[i] = binaryData.readInt16LE(12 + i*6) / 1024;\n\t\t\tres.Z[i] = binaryData.readInt16LE(14 + i*6) / 1024;\n\t\t}\n\t\t\n\t\t\n\t\treturn res;\t\t\n\t}\n\t\n\t\n\t//Reports - Accelerometer 2\t\n\tvar accelerometer2ObjGet = function(binaryData) {\n\t\t//Total number of samples\n\t\tvar len = \tMath.floor(2 * (binaryData.length - 10) / 3);\t\n\t\tvar tempArr = [new Float32Array(len / 3),new Float32Array(len / 3),new Float32Array(len / 3)];\n\t\t\n\t\tvar payloadIndex = 10;\n\t\tfor (var i=0; i < len ; i = i+2){\n\t\t\t//Get Raw data\n\t\t\ttempArr[i  % 3][Math.floor(i / 3)] = ((binaryData[payloadIndex + 1] & 0x0F) << 8) | binaryData[payloadIndex];          \n\t\t\ttempArr[(i + 1) % 3][ Math.floor((i+1) / 3)] =  (binaryData[payloadIndex + 2] << 4) | (binaryData[payloadIndex + 1] >> 4 )\n\t\t\tpayloadIndex = payloadIndex + 3;\n\t\t}\n\t\t\n\t\t//Convert to a/g\t\t\n\t\tfor (var j=0; j < tempArr.length ; j++){\n\t\t\tfor (var i=0; i < tempArr[0].length ; i++){\n\t\t\t\ttempArr[j][i] = (tempArr[j][i] - 2048) * 1.8  / (4096 * 0.08) ;\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\treturn {X:tempArr[0], Y:tempArr[1], Z:tempArr[2]};\n\t}\n\t\n\t//Reports - Magnetometer\n\tvar magnetometerObjGet = function(binaryData) {\n\t\tvar len = \tMath.floor( (binaryData.length - 10) / 2);\t\t\t\n\t\tvar tempArr = [new Int32Array(len / 3),new Int32Array(len / 3),new Int32Array(len / 3)];\n\t\t\n\t\tfor (var i=0; i < len  ; i++){\n\t\t\ttempArr[i  % 3][Math.floor(i / 3)] = 1000* binaryData.readInt16LE(10 + i*2) / 16;\t\t\t\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\treturn {X:tempArr[0], Y:tempArr[1], Z:tempArr[2]};\n\t}\n\t\n\t\n\t//Reports - Temperature\n\tvar temperatureObjGet = function(binaryData) {\n\t\treturn binaryData.readInt16LE(10)/128;\n\t}\t\n\t\n\t//Reports - MIC\n\tvar micObjGet = function(binaryData) {\n\t\tvar len = \tMath.floor( (binaryData.length - 10) / 2);\t\t\t\n\t\tvar res =  new Float32Array(len);\n\t\t\n\t\tfor (var i=0; i < len  ; i++){\n\t\t\tres[i] = binaryData.readInt16LE(10 + i*2) * Math.pow(10, (130/20))/32768;\t\t\t\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\treturn res;\n\t}\n\t\n\t\n\t//Message parsers - Set config\n\t\n\t//Set config (Ack)\n\tvar setConfigObjGet = function(binaryData) {\t\n\t\t//ACK\t\n\t\tif ((!binaryData) || (binaryData.length != 2))\n\t\t\treturn null;\n\t\tres[\"Ack\"] = true;\n\t\tres[\"Result\"] = binaryData[1];\n\t\tif (binaryData[1] != 0)\n\t\t\tres[\"Error\"] = true;\n\t\treturn res;\t\t\n\t}\n\t//Set config To binary - Example obj = {\"Enable\":false,\"Temp\":false,\"ACC1\":false,\"ACC2\":false,\"MAG\":false,\"MIC\":false,\"Interval\":5, \"Repetition\":0}\n\tvar setConfigBinGet = function(obj) {\n\t\tif (!obj)\n\t\t\treturn null;\n\t\tvar res = new Buffer.alloc(24);\n\t\tres[1] = 0x4 | 0x2; //Bitmask - Set activation period and common\n\t\tres[2] = 0x1; //Raw data\n\t\tres[3] = 0x40 | 0x1;//Common (Aux channel) and transmit on\t\t\n\t\tres.writeUInt16LE(obj[\"Interval\"] != undefined?obj[\"Interval\"]:1, 12); //Interval in minutes\n\t\tres[14] = obj[\"Repetition\"] != undefined?obj[\"Repetition\"]:0; //Transmit repitition (1+Value) - default:0\t\t\n\t\tres[15] = (obj[\"Enable\"] == true)?0x1:0;//Active modules - Raw data\n\t\t\n\t\tres[16] = 0;\n\t\tfor (var i=0; i<REPORT_TYPE.length;i++){\n\t\t\tif (obj[REPORT_TYPE[i].name] == true){\n\t\t\t\tres[16] |= (1 << i);\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\treturn res;\n\t}\n\t\n\t//Message parsers - Get config\n\t\n\t//Get config - request\n\tvar getConfigBinGet = function() {\n\t\treturn new Buffer.alloc(1);\n\t}\n\tvar getConfigObjGet = function(binaryData) {\n\t\tres = {};\n\t\t\n\t\t//ACK\n\t\tif (binaryData.length < 7)\n\t\t\treturn null;\n\t\t\n\t\tres[\"CommChannel\"] = COMM_CHANNEL[binaryData[1] & (1 << 0)];\n\t\tres[\"Vibrator\"] = ((binaryData[1] >> 2) & 0x1) == 1;\n\t\tres[\"Transmit\"] = ((binaryData[1] >> 6) & 0x1) == 1;\n\t\tres[\"Save\"] = ((binaryData[1] >> 7) & 0x1) == 1;\n\t\tres[\"Repetition\"] = binaryData[2];\n\t\tres[\"Interval\"] = binaryData.readUInt16LE(3);\n\t\tres[\"Enable\"] = ((binaryData[5] & 0x1) != 0);\n\t\tfor (var i=0; i<REPORT_TYPE.length;i++){\n\t\t\tres[REPORT_TYPE[i].name] = (((binaryData[6] >> i) & 0x1) == 1);\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\t\n\t//Parsing map\n\tconst MESSAGE_TYPE = {\n\t  HELLO:\t {code:0x00, name:\"Hello\",  \ttoObjFunc:helloMessageObjGet, toBinFunc:helloMessageBinGet },\n\t  RESET:\t {code:0x01, name:\"Reset\",  \ttoObjFunc:resetMessageObjGet, toBinFunc:resetMessageBinGet },\n\t  GET_CONFIG:{code:0x02, name:\"GetConfig\",  toObjFunc:getConfigObjGet, toBinFunc:getConfigBinGet  },\n\t  SET_CONFIG:{code:0x03, name:\"SetConfig\",  toObjFunc:setConfigObjGet, toBinFunc:setConfigBinGet },\n\t  REPORT:\t {code:0xFF, name:\"Report\",  \ttoObjFunc:reportMessageObjGet}\n\t  \n\t};\n\n\tconst REPORT_TYPE = [\n\t\t{name:\"ACC1\", \tfunc:accelerometer1ObjGet} ,\t//AXL362\n\t\t{name:\"ACC2\", \tfunc:accelerometer2ObjGet} , \t//ADXL362\n\t\t{name:\"MAG\", \tfunc:magnetometerObjGet} ,\t//BMM150\t\n\t\t{name:\"Temp\", \tfunc:temperatureObjGet} ,\t\t//ADT7410\n\t\t{name:\"MIC\", \tfunc:micObjGet} ,\t\t\t\t//IM69D130\n\t];\n\t\n\t\n\t//Get parsed object\n\tthis.objectGet = function(binaryData) {\n\t\tvar res;\n\t\t\n\t\tif ((Buffer.isBuffer(binaryData) == false) || (binaryData.length < 1))\n\t\t\treturn null;\n\t\tvar msgType;\n\t\tswitch (binaryData[0]){ //Message type\n\t\t\tcase MESSAGE_TYPE.HELLO.code:\n\t\t\t\tmsgType = MESSAGE_TYPE.HELLO;\n\t\t\t\tbreak;\n\t\t\tcase MESSAGE_TYPE.RESET.code:\n\t\t\t\tmsgType = MESSAGE_TYPE.RESET;\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase MESSAGE_TYPE.GET_CONFIG.code:\n\t\t\t\tmsgType = MESSAGE_TYPE.GET_CONFIG;\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase MESSAGE_TYPE.SET_CONFIG.code:\n\t\t\t\tmsgType = MESSAGE_TYPE.SET_CONFIG;\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase MESSAGE_TYPE.REPORT.code:\n\t\t\t\tmsgType = MESSAGE_TYPE.REPORT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t\ttry{\n\t\t\tres = msgType.toObjFunc(binaryData);\n\t\t}\n\t\tcatch{\n\t\t\tconsole.error(\"Error:Malformed Message\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (res == null)\n\t\t\treturn null;\n\t\treturn {\"Type\": msgType.name, \"Data\":res};\n\t}\n\t\n\t//Get parsed object\n\tthis.binaryMsgGet = function(obj) {\n\t\tvar msgType;\n\t\t\n\t\tif ((!obj) || (!obj.Type))\n\t\t\treturn null;\n\t\t\n\t\tswitch (obj.Type){\n\t\t\tcase MESSAGE_TYPE.HELLO.name:\n\t\t\t\tmsgType = MESSAGE_TYPE.HELLO;\n\t\t\t\tbreak;\n\t\t\tcase MESSAGE_TYPE.RESET.name:\n\t\t\t\tmsgType = MESSAGE_TYPE.RESET;\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase MESSAGE_TYPE.GET_CONFIG.name:\n\t\t\t\tmsgType = MESSAGE_TYPE.GET_CONFIG;\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tcase MESSAGE_TYPE.SET_CONFIG.name:\n\t\t\t\tmsgType = MESSAGE_TYPE.SET_CONFIG;\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn null;\t\t\n\t\t}\n\t\t\n\t\tres = msgType.toBinFunc(obj.Data);\t\t\n\t\tif (res == null)\n\t\t\treturn null;\n\t\t\n\t\tres[0] = msgType.code;\n\t\treturn res;\t\t\n\t}\t\n\t\n\t\n};\n\n\n\n\n\nglobal.set('iCOMOX', new parser());\nconsole.log(\"iCOMOX parser registered version:\" + global.get('iCOMOX').VERSION);","finalize":"","x":110,"y":80,"wires":[[]],"info":"Defined the iCoMoX Object, for parser nodes instances"}]