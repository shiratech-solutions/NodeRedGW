[{"id":"91830877.d26b18","type":"tab","label":"Flow 1","disabled":false,"info":""},{"id":"d06c3515.0071e8","type":"mqtt-broker","z":"","name":"LocalHost","broker":"localhost","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"d4ab7732.3517c8","type":"mqtt in","z":"91830877.d26b18","name":"iCoMoX-MQTT-In","topic":"iCOMOX/+/IN","qos":"2","datatype":"auto","broker":"d06c3515.0071e8","x":100,"y":240,"wires":[["ed442511.2272f8","9274c23a.83b3f"]]},{"id":"8eadd70d.fdc248","type":"function","z":"91830877.d26b18","name":"iCoMox-IoT Central Reformatter","func":"//Function to return max,min and average of array\nvar arrCalc = context.get('ArrCalc');\n\nif (msg.payload.type != \"Report\")\n    return [null];\n    \n//Message data\nvar data = msg.payload[msg.payload.reportType];\nvar reportType = msg.payload.reportType;\nvar res;\n\n\n//New payload structure for IoTCentral\nmsg.payload =  {\n    \"device\": {\n        \"deviceId\":msg.topic.split('/')[1]\n    },\n    \"measurements\": {\n    },   \n    \"properties\":{\n        \"asetting\": \"off\"\n    }\n};\n\n\nswitch (reportType){\n    case \"Temp\":\n        msg.payload.measurements[\"Temp\"] = data;\n        break;\n    case \"ACC1\":\n        res  = {X:arrCalc(data.X),Y:arrCalc(data.Y),Z:arrCalc(data.Z)};\n        msg.payload.measurements = {\n            \"Acc1XMax\":res.X.max, \"Acc1XMin\":res.X.min, \"Acc1XAvg\":res.X.avg,\n            \"Acc1YMax\":res.Y.max, \"Acc1YMin\":res.Y.min, \"Acc1YAvg\":res.Y.avg,\n            \"Acc1ZMax\":res.Z.max, \"Acc1ZMin\":res.Z.min, \"Acc1ZAvg\":res.Z.avg\n        };\n        break;\n    \n    case \"ACC2\":\n        res  = {X:arrCalc(data.X),Y:arrCalc(data.Y),Z:arrCalc(data.Z)};\n        msg.payload.measurements = {\n            \"Acc2XMax\":res.X.max, \"Acc2XMin\":res.X.min, \"Acc2XAvg\":res.X.avg,\n            \"Acc2YMax\":res.Y.max, \"Acc2YMin\":res.Y.min, \"Acc2YAvg\":res.Y.avg,\n            \"Acc2ZMax\":res.Z.max, \"Acc2ZMin\":res.Z.min, \"Acc2ZAvg\":res.Z.avg\n        };\n        break;\n    \n    case \"MAG\":\n        res  = {X:arrCalc(data.X),Y:arrCalc(data.Y),Z:arrCalc(data.Z)};\n        msg.payload.measurements = {\n            \"MagXMax\":res.X.max, \"MagXMin\":res.X.min, \"MagXAvg\":res.X.avg,\n            \"MagYMax\":res.Y.max, \"MagYMin\":res.Y.min, \"MagYAvg\":res.Y.avg,\n            \"MagZMax\":res.Z.max, \"MagZMin\":res.Z.min, \"MagZAvg\":res.Z.avg\n        };\n        break;\n    \n    case \"MIC\":\n        res = arrCalc(data);\n         msg.payload.measurements = { \"MicMax\":res.max, \"MicMin\":res.min, \"MicAvg\":res.avg};\n        break;\n    default:\n        return [null];\n}\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is deployed.\ncontext.set('ArrCalc', function (arr){\n    console.log(\"arr:\"+arr.length);\n    var sum = arr[0], res = {max :arr[0],min:arr[0] };\n    \n    for (var i=1; i < arr.length ; i++){\n        sum+=arr[i];\n        res.min = Math.min(res.min, arr[i]);\n        res.max = Math.max(res.max, arr[i]);\n    }\n    res.avg = sum / arr.length;\n    \n    return res;\n}\n);","finalize":"","x":670,"y":240,"wires":[["9274c23a.83b3f","49802a53.017af4"]]},{"id":"9274c23a.83b3f","type":"debug","z":"91830877.d26b18","name":"","active":true,"tosidebar":true,"console":true,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":510,"y":380,"wires":[]},{"id":"51c0a4da.4cb91c","type":"azure-iotc-bridge","z":"91830877.d26b18","name":"","registrationHost":"global.azure-devices-provisioning.net","idScope":"0ne00074021","sasToken":"gTYIoPFs7raJpVV7LH1YtII9Iy1l7QPlByvQZG90x2dvVpO+367NPkXHyoPAgNmpspoqZGE/8mGA56bC0t81eA==","x":990,"y":240,"wires":[["9274c23a.83b3f"]]},{"id":"ed442511.2272f8","type":"function","z":"91830877.d26b18","name":"iCoMoX Parser bin to obj","func":"\nvar iCoMoXParser = global.get('iCoMoX');\nif (iCoMoXParser  == null)\n    return [null];\n\nvar iCoMoxParsedMsg = iCoMoXParser.objectGet(msg.payload );    \nif (iCoMoxParsedMsg == null)\n    return [null];\n\nmsg.payload = iCoMoxParsedMsg;\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":370,"y":240,"wires":[["8eadd70d.fdc248","49802a53.017af4"]]},{"id":"49802a53.017af4","type":"function","z":"91830877.d26b18","name":"Stringify obj","func":"console.log(JSON.stringify(msg.payload));\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":690,"y":120,"wires":[[]]},{"id":"f22843e.d3516c","type":"Azure IoT Central","z":"91830877.d26b18","scopeid":"0ne00074021","deviceid":"iCoMoX-ID1","primarykey":"jQnNWJ6YmXGHbjh2/Z7L+XGJGJrAw3Lcq4oUvQLO8sw=","command1":"control","command2":"","command3":"","command4":"","command5":"","property1":"","property2":"","property3":"","property4":"","property5":"","transport":"mqtt","auth":"sas","certfile":"","certkeyfile":"","passwordi":"","x":330,"y":600,"wires":[["9274c23a.83b3f","acc357e.7e479a8"]]},{"id":"acc357e.7e479a8","type":"function","z":"91830877.d26b18","name":"IoT Central Commands","func":"if(flow.get('control')){\n    console.log(\"Control commands already registered\");\n    return;   \n}\nelse{\n   console.log(\"Registering control commands\");\n\n}\n\nfunction onControl(request, response) {\n  node.log (\"Method name: \" + request.methodName );\n  node.log (\"Val7ue: \" + JSON.stringify(request.payload));\n  \n  data = \"you said:\" + String(request.payload);\n\n  response.send(200, data , (err) => {\n    if (err) {\n      node.log('Unable to send method response: ' + err.toString());\n    }\n    else {\n            node.log('Response to method \\'' + request.methodName + '\\' sent successfully... ' + data);\n        }\n  });\n}\n\nflow.set('control',onControl);\n","outputs":1,"noerr":0,"initialize":"","finalize":"","x":630,"y":600,"wires":[["9274c23a.83b3f","49802a53.017af4"]]},{"id":"b885ee66.fcd67","type":"delay","z":"91830877.d26b18","name":"","pauseType":"rate","timeout":"5","timeoutUnits":"seconds","rate":"5","nbRateUnits":"5","rateUnits":"minute","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":1020,"y":560,"wires":[[]]},{"id":"a035bcb.eff064","type":"comment","z":"91830877.d26b18","name":"iCoMoX to Cloud","info":"","x":110,"y":180,"wires":[]},{"id":"b76a4b84.8caf88","type":"comment","z":"91830877.d26b18","name":"Cloud to iCoMoX","info":"","x":100,"y":440,"wires":[]},{"id":"db113206.13a65","type":"inject","z":"91830877.d26b18","name":"Init connection","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":"2","topic":"","payload":"{}","payloadType":"json","x":100,"y":600,"wires":[["f22843e.d3516c"]],"info":"Used to initialize the connection (One message)"},{"id":"9098fbe5.d1cd48","type":"function","z":"91830877.d26b18","name":"iCoMox Parser def","func":"","outputs":1,"noerr":0,"initialize":"// Code added here will be run once\n// whenever the node is deployed.\nvar parser = function iCoMoXParser(binaryData) {\n\tconst VERSION = \"0.0.2\";\n\t\n\tconst BOARD_TYPE = [\"SMIP\",\"NB_IOT\",\"POE\"];\n\tconst FW_BRANCH = [\"Kit\",\"Suitcase\"];\n\t\n\t\n\n\t//Utility functions\n\tvar twoDigStr =  function(num){\n\t\treturn ('0' + (num).toString(10)).slice(-2);\n\t}\n\tvar toHexStr =  function(num){\n\t\treturn ('0' + (num).toString(16)).slice(-2);\n\t}\n\t\n\t//Message parsers - Hello\n\tvar helloMessageObjGet = function(binaryData) {\n\t\tvar res = {};\n\t\tif (binaryData[1] >= BOARD_TYPE.length)\n\t\t\treturn null;\n\t\tif (binaryData[23] >= FW_BRANCH.length)\n\t\t\treturn null;\n\t\tres[\"BoardType\"] = BOARD_TYPE[binaryData[1]];\n\t\tres[\"Board ver\"] = binaryData[2] + \".\" + binaryData[3];\n\t\tres[\"MCU Serial\"]=\"\";\n\t\tfor (var i=0; i< 16; i++)\n\t\t\tres[\"MCU Serial\"]+= toHexStr(binaryData[4+i]);   \n\t\tres[\"FW ver\"] = binaryData[20] + \".\" + binaryData[21] + \".\" + binaryData[22] + FW_BRANCH[binaryData[23]];\n\t\tres[\"FW build\"] = \tbinaryData[27] + \".\"  + binaryData[26] + \".\" + binaryData.readInt16LE(24)  +   \" \" + binaryData[28] + \":\" + twoDigStr(binaryData[29]) + \":\" + twoDigStr(binaryData[30]);\n\t\tres[\"BIT status\"] = \"0x\" + toHexStr(binaryData[31]);\n\t\tres[\"Part num\"] = binaryData.slice(32,32+32).toString().replace(/\\0[\\s\\S]*$/g,'');\n\t\tres[\"Serial\"] = binaryData.slice(64,64+32).toString().replace(/\\0[\\s\\S]*$/g,'');\n\t\tres[\"Name\"] = binaryData.slice(96,96+32).toString().replace(/\\0[\\s\\S]*$/g,'');\n\t\t\n\t\treturn res;\n\t}\n\t\n\t//Message parsers - Reports\n\tvar timestampGet = function(binaryData) {\n\t\tif ((binaryData.length < 10) && (this.isReportMessage()==true))\n\t\t\treturn null;\t\t\n\t\t\n\t\treturn new Date((Number(binaryData.readBigInt64LE(2) ) /32768) * 1000);\n\t\t\n\t}\n\tvar reportMessageObjGet = function(binaryData) {\n\t\tvar res = {};\n\t\t\n\t\tif (binaryData[1] >= REPORT_TYPE.length)\n\t\t\treturn null;\n\t\tres.reportType = REPORT_TYPE[binaryData[1]].name;\n\t\tres[res.reportType] = REPORT_TYPE[binaryData[1]].func(binaryData);\n\t\tif (res[res.reportType] == null)\n\t\t\treturn null;\n\t\tres.timestamp = timestampGet(binaryData);\n\t\t\n\t\treturn res;\n\t}\n\t\n\t\n\t\n\t\n\t\n\t//Reports - Accelerometer 1\t\n\tvar accelerometer1ObjGet = function(binaryData) {\n\t\t//Number of samples per axis\n\t\tvar len = \t(binaryData.length - 10) / (3*2);\t\n\t\tvar res = {X:new Float32Array(len),Y:new Float32Array(len),Z:new Float32Array(len)};\n\t\t\n\t\t \n\t\tfor (var i=0; i < len; i++){\n\t\t\tres.X[i] = binaryData.readInt16LE(10 + i*6) / 1024;\n\t\t\tres.Y[i] = binaryData.readInt16LE(12 + i*6) / 1024;\n\t\t\tres.Z[i] = binaryData.readInt16LE(14 + i*6) / 1024;\n\t\t}\n\t\t\n\t\treturn res;\t\t\n\t}\n\t\n\t\n\t//Reports - Accelerometer 2\t\n\tvar accelerometer2ObjGet = function(binaryData) {\n\t\t//Total number of samples\n\t\tvar len = \tMath.floor(2 * (binaryData.length - 10) / 3);\t\n\t\tvar tempArr = [new Float32Array(len / 3),new Float32Array(len / 3),new Float32Array(len / 3)];\n\t\t\n\t\tvar payloadIndex = 10;\n\t\tfor (var i=0; i < len ; i = i+2){\n\t\t\t//Get Raw data\n\t\t\ttempArr[i  % 3][Math.floor(i / 3)] = ((binaryData[payloadIndex + 1] & 0x0F) << 8) | binaryData[payloadIndex];          \n\t\t\ttempArr[(i + 1) % 3][ Math.floor((i+1) / 3)] =  (binaryData[payloadIndex + 2] << 4) | (binaryData[payloadIndex + 1] >> 4 )\n\t\t\tpayloadIndex = payloadIndex + 3;\n\t\t}\n\t\t\n\t\t//Convert to a/g\t\t\n\t\tfor (var j=0; j < tempArr.length ; j++){\n\t\t\tfor (var i=0; i < tempArr[0].length ; i++){\n\t\t\t\ttempArr[j][i] = (tempArr[j][i] - 2048) * 1.8  / (4096 * 0.08) ;\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn {X:tempArr[0], Y:tempArr[1], Z:tempArr[2]};\n\t}\n\t\n\t//Reports - Magnetometer\n\tvar magnetometerObjGet = function(binaryData) {\n\t\tvar len = \tMath.floor( (binaryData.length - 10) / 2);\t\t\t\n\t\tvar tempArr = [new Int32Array(len / 3),new Int32Array(len / 3),new Int32Array(len / 3)];\n\t\t\n\t\tfor (var i=0; i < len  ; i++){\n\t\t\ttempArr[i  % 3][Math.floor(i / 3)] = 1000* binaryData.readInt16LE(10 + i*2) / 16;\t\t\t\t\t\t\n\t\t}\n\t\t\n\t\treturn {X:tempArr[0], Y:tempArr[1], Z:tempArr[2]};\n\t}\n\t\n\t\n\t//Reports - Temperature\n\tvar temperatureObjGet = function(binaryData) {\n\t\treturn binaryData.readInt16LE(10)/128;\n\t}\t\n\t\n\t//Reports - MIC\n\tvar micObjGet = function(binaryData) {\n\t\tvar len = \tMath.floor( (binaryData.length - 10) / 2);\t\t\t\n\t\tvar res =  new Float32Array(len);\n\t\t\n\t\tfor (var i=0; i < len  ; i++){\n\t\t\tres[i] = binaryData.readInt16LE(10 + i*2) * Math.pow(10, (130/20))/32768;\t\t\t\t\t\t\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\t\n\t//To binary\n\tvar setConfigBinGet = function(obj) {\n\t\tif (!obj)\n\t\t\treturn null;\n\t\tvar res = new Buffer.alloc(24);\n\t\tres[1] = 0x4 | 0x2; //Bitmask - Set activation period and common\n\t\tres[2] = 0x1; //Raw data\n\t\tres[3] = 0x40 | 0x1;//Common (Aux channel) and transmit on\n\t\tres.writeUInt16LE(obj[\"interval\"] != undefined?obj[\"interval\"]:1, 12); //Interval in minutes\n\t\tres[14] = 0; //Transmit repitition (1+Value)\t\t\n\t\tres[15] = (obj[\"enable\"] == true)?0x1:0;//Active modules - Raw data\n\t\tres[16] = (obj[\"enable\"] == true)?0x1F:0; //Active Sensors - enable/disable\n\t\t\n\t\treturn res;\n\t}\n\t\n\t\n\t\n\t//Parsing map\n\tconst MESSAGE_TYPE = {\n\t  HELLO:\t {code:0x00, name:\"Hello\",  \ttoObjFunc:helloMessageObjGet },\n\t  RESET:\t {code:0x01, name:\"Reset\",  \t/*toObjFunc:helloMessageGet*/ },\n\t  GET_CONFIG:{code:0x02, name:\"GetConfig\",  /*toObjFunc:helloMessageGet*/ },\n\t  SET_CONFIG:{code:0x03, name:\"SetConfig\",  /*toObjFunc:helloMessageGet,*/ toBinFunc:setConfigBinGet },\n\t  REPORT:\t {code:0xFF, name:\"Report\",  \ttoObjFunc:reportMessageObjGet}\n\t  \n\t};\n\n\tconst REPORT_TYPE = [\n\t\t{name:\"ACC1\", \tfunc:accelerometer1ObjGet} ,\t//AXL362\n\t\t{name:\"ACC2\", \tfunc:accelerometer2ObjGet} , \t//ADXL362\n\t\t{name:\"MAG\", \tfunc:magnetometerObjGet} ,\t//BMM150\t\n\t\t{name:\"Temp\", \tfunc:temperatureObjGet} ,\t\t//ADT7410\n\t\t{name:\"MIC\", \tfunc:micObjGet} ,\t\t\t\t//IM69D130\n\t];\n\t\n\t\n\t//Get parsed object\n\tthis.objectGet = function(binaryData) {\n\t\tvar res;\n\t\t\n\t\tif ((Buffer.isBuffer(binaryData) == false) || (binaryData.length < 1))\n\t\t\treturn null;\n\t\tvar msgType;\n\t\tswitch (binaryData[0]){ //Message type\n\t\t\tcase MESSAGE_TYPE.REPORT.code:\n\t\t\t\tmsgType = MESSAGE_TYPE.REPORT;\n\t\t\t\tbreak;\n\t\t\tcase MESSAGE_TYPE.HELLO.code:\n\t\t\t\tmsgType = MESSAGE_TYPE.HELLO;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t\t\n\t\tres = msgType.toObjFunc(binaryData);\n\t\tif (res == null)\n\t\t\treturn null;\n\t\tres[\"type\"] = msgType.name;\n\t\treturn res;\t\t\n\t}\n\t\n\t//Get parsed object\n\tthis.binaryMsgGet = function(type, obj) {\n\t\tvar msgType;\n\t\t\n\t\tif ((!type) || (!obj))\n\t\t\treturn null;\n\t\t\n\t\tswitch (type){\n\t\t\tcase MESSAGE_TYPE.SET_CONFIG.name:\n\t\t\t\tmsgType = MESSAGE_TYPE.SET_CONFIG;\t\t\t\t\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn null;\t\t\n\t\t}\n\t\tres = msgType.toBinFunc(obj);\t\t\n\t\tif (res == null)\n\t\t\treturn null;\n\t\tres[0] = msgType.code;\n\t\treturn res;\t\t\n\t}\t\n\t\n};\n\n\nglobal.set('iCoMoX', new parser());\nconsole.log(\"iCOMOX parser registered\");","finalize":"","x":110,"y":60,"wires":[[]],"info":"Defined the iCoMoX Object, for parser nodes instances"},{"id":"edd1ba73.223df8","type":"function","z":"91830877.d26b18","name":"iCoMoX Parser obj to bin","func":"\nvar iCoMoXParser = global.get('iCoMoX');\nif (iCoMoXParser  == null)\n    return [null];\n\nvar iCoMoxParsedMsg = iCoMoXParser.binaryMsgGet(msg.payload );    \nif (iCoMoxParsedMsg == null)\n    return [null];\n\nmsg.payload = iCoMoxParsedMsg;\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":970,"y":440,"wires":[[]]},{"id":"2ea1ad0e.b72f12","type":"mqtt out","z":"91830877.d26b18","name":"","topic":"iCOMOX/+/OUT","qos":"","retain":"","broker":"d06c3515.0071e8","x":1250,"y":440,"wires":[]}]